--
-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
--

daml 1.2
module DA.RefApps.SupplyChain.Main where

import DA.Action
import DA.List
import DA.Date
import DA.Optional

import DA.RefApps.SupplyChain.Types

-- Relationships

template BuyerSellerRelationshipInvitation
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer
    controller seller can
      BuyerSellerRelationshipInvitation_Accept: ContractId BuyerSellerRelationship
        do
          create $ BuyerSellerRelationship with ..

template BuyerSellerRelationship
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer, seller
    controller buyer can
      nonconsuming BuyerSellerRelationship_SendQuoteRequest: ContractId QuoteRequest
        with
          products: [OrderedProduct]
        do
          create $ QuoteRequest with ..

-- Quote request

template QuoteRequest
  with
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory buyer
    controller seller can
      QuoteRequest_Accept: ContractId QuoteRequestAccepted
        do
          create QuoteRequestAccepted with
            quoteId = self, ..

template QuoteRequestAccepted
  with
    quoteId: ContractId QuoteRequest -- opaque id of the workflow initiated by this QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory seller
    controller seller can
      QuoteRequestAccepted_SendToSupplier : ContractId QuoteRequestSupplyInvitation
        with
          supplier: Party
        do
          create QuoteRequestSupplyInvitation with supplier = supplier, ..

template QuoteRequestSupplyInvitation
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller
    controller supplier can
      QuoteRequestSupplyInvitation_Accept : ContractId SupplyRequest
        do
          create SupplyRequest with ..


-- Supplier can initiate the inventory reservation and transport quote collection with this template
template SupplyRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller, supplier
    controller supplier can
      SupplyRequest_StartPriceCollection: (ContractId TransportQuoteRequestPending, [ContractId InventoryQuoteRequest], [ContractId TransportQuoteRequest])
        with
          warehouses: [Party]
          transportCompanies: [Party]
        do
          (invRequests, allocations) <- fmap (unzip . concat) $ forA warehouses
              (\w -> forA products
                (\product -> do
                  req <- create InventoryQuoteRequest with
                    warehouse = w, ..
                  let wa = WarehouseAllocationWithDates (WarehouseAllocation product.productName w product.quantity) product.deliveryFrom product.deliveryTo
                  return (req, wa)))
          quoteRequests <- fmap concat $ forA transportCompanies
              (\tc -> forA allocations
                (\allocations ->
                  create TransportQuoteRequest with
                    transportCompany = tc
                    item = allocations, ..))

          pending <- create TransportQuoteRequestPending with
            items = allocations, ..
          return (pending, invRequests, quoteRequests)

-- Inventory

template InventoryItem
  with
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier
    controller supplier can
      InventoryItem_SplitAndLock: (ContractId InventoryItem, ContractId LockedInventoryItem)
        with
          quantityToLock: Int
          quoteRequestId: ContractId QuoteRequest
        do
          let remainingQuantity = quantity - quantityToLock
          assertMsg "Non-positive remaining quantity." $ remainingQuantity > 0

          this2 <- create InventoryItem with quantity = remainingQuantity, ..

          warehousePaymentRequestCid <- create PaymentRequest with
            payer = supplier
            payee = warehouse
            price = unitPrice * intToDecimal quantityToLock

          locked <- create LockedInventoryItem with quantity = quantityToLock, .. --TODO
          return (this2, locked)

template LockedInventoryItem
  with
    quoteRequestId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse
    observer supplier

template InventoryQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    product: OrderedProduct
  where
    signatory supplier

    controller warehouse can
      InventoryQuoteRequest_Accept: ContractId InventoryQuote
        with
          inventoryItemCid: ContractId InventoryItem
        do
          item <- fetch inventoryItemCid
          let reservedQuantity = min item.quantity product.quantity
          create InventoryQuote with
            quantity = reservedQuantity
            price = item.unitPrice * intToDecimal reservedQuantity
            productName = product.productName, ..

template InventoryQuote
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    price: Decimal
  where
    signatory warehouse

-- Supplier

-- template InventoryLockingBotTrigger
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     whatToLock: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       WarehouseInvetoryLockingBotTrigger_Lock: (ContractId RequestDeliveryProposal, [ContractId LockedInventoryItem])
--         with
--           inventoryCids : [ContractId InventoryItem]
--         do
--           inventory <- forA inventoryCids fetch
--           let inventoryPair = zip inventoryCids inventory
--           lockResult <- forA whatToLock (\alloc -> do
--               let inventoryItem = fromSome $ find (\(cid, i) -> i.productName == alloc.allocation.productName && i.warehouse == alloc.allocation.warehouse) inventoryPair
--               exercise (fst inventoryItem) $ InventoryItem_SplitAndLock with
--                                                 quantityToLock = alloc.allocation.quantity
--             )
--           let (_, lockedCids) = unzip lockResult
--           proposal <- create RequestDeliveryProposal with
--                   items = whatToLock, ..
--           return (proposal, lockedCids)

-- template RequestDeliveryProposal
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     items: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       RequestDeliveryProposal_RequestTransportQuote: (ContractId TransportQuoteRequestPending, [ContractId TransportQuoteRequest])
--         with
--           transportCompanies: [Party]
--         do
--           qRequests <- forA transportCompanies \tC -> create TransportQuoteRequest with
--                                                   transportCompany = tC
--                                                   supplier = supplier
--                                                   items = items
--           pending <- create TransportQuoteRequestPending with ..
--           return (pending, qRequests)

data TransportQuoteItem = TransportQuoteItem with
    transportableQuantity: Int
    price: Decimal -- total price corresponding to transportableQuantity
    deliveryDate: Date
  deriving (Eq, Show)

template TransportQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    buyer: Party
    buyerAddress: Text
    item: WarehouseAllocationWithDates
  where
    signatory supplier
    controller transportCompany can
      TransportQuoteRequest_Accept: ContractId TransportQuote
        with
          quoteItem: TransportQuoteItem
        do
          create TransportQuote with item = (item.allocation, quoteItem), ..

template TransportQuote
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: (WarehouseAllocation, TransportQuoteItem)
  where
    signatory supplier, transportCompany

    controller supplier can
      TransportQuote_Lock: ContractId LockedTransportCapacity
        with
          quantity: Int
        do
          transportPaymentRequestCid <- create PaymentRequest with
                price = (snd item).price * (intToDecimal quantity) / intToDecimal (snd item).transportableQuantity
                payer = supplier
                payee = transportCompany
          create LockedTransportCapacity with
                quoteId = quoteId
                transportCompany = transportCompany
                supplier = supplier
                item = fst item
                deliveryDate = (snd item).deliveryDate
                transportPaymentRequestCid = transportPaymentRequestCid

template TransportQuoteRequestPending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      -- Supplier waits no more, bot collects available TransportQuote-s
      TransportQuoteRequestPending_ChooseTransport: ContractId ChooseTransportBotTrigger
        do
          create ChooseTransportBotTrigger with ..

template ChooseTransportBotTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      ChooseTransportBotTrigger_Proceed: ContractId AggregatedQuotePending
        with
          transportQuoteCids: [ContractId TransportQuote]
          inventoryQuoteCids: [ContractId InventoryQuote]
          inventoryItemCids: [ContractId InventoryItem]
        do
          proportionalQuotes <- bestPriceDelivery transportQuoteCids inventoryQuoteCids items
          inventoryItems <- forA inventoryItemCids fetch
          let inventoryItemsWithCid = zip inventoryItems inventoryItemCids
          locks <- foldlA (\ summedLocks pq -> do
              transportQuote <- fetch pq.transportQuoteCid
              let inventoryItemWithCid = head $ filter (\itemWithCid -> (fst itemWithCid).productName == (fst transportQuote.item).productName) summedLocks.liveInventoryItems
              lockedTransportCapacity <- exercise pq.transportQuoteCid TransportQuote_Lock with quantity = pq.quantity
              let inventoryItemCid = snd inventoryItemWithCid
              (newInventoryCid, lockedInventoryCid) <- exercise inventoryItemCid $ InventoryItem_SplitAndLock with
                quantityToLock = pq.quantity
                quoteRequestId = quoteId
              newInventory <- fetch newInventoryCid
              let allocation = TransportedWarehouseAllocation with allocation = pq.allocation.allocation;  transportCompany = transportQuote.transportCompany; deliveryDate = (snd transportQuote.item).deliveryDate
                  prevLiveInventoriesWithoutArchived = filter (\inventoryItemWithCid -> (snd inventoryItemWithCid) /= inventoryItemCid) summedLocks.liveInventoryItems
                  updatedInventories = (newInventory, newInventoryCid) :: prevLiveInventoriesWithoutArchived
              return SummedLocks with liveInventoryItems = updatedInventories; locksSoFar = [((allocation, (snd transportQuote.item).price), lockedTransportCapacity, lockedInventoryCid)] ++ summedLocks.locksSoFar
              ) (SummedLocks with liveInventoryItems = inventoryItemsWithCid; locksSoFar = []) proportionalQuotes
          create AggregatedQuotePending with
            quoteId = quoteId
            supplier = supplier
            buyer = buyer
            seller = seller
            items = locks.locksSoFar

data SummedLocks =
  SummedLocks {
    liveInventoryItems: [(InventoryItem, ContractId InventoryItem)];
    locksSoFar: [(TransportedWarehouseAllocationWithPrice, ContractId LockedTransportCapacity, ContractId LockedInventoryItem)]
  } deriving (Eq, Show)


template LockedTransportCapacity
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: WarehouseAllocation -- TODO add Address!! down from TransportQuoteRequest
    deliveryDate: Date
    transportPaymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer supplier

    controller supplier can
      LockedTransportCapacity_ReleaseAndPay: ContractId PaymentObligation
        do
          exercise transportPaymentRequestCid PaymentRequest_Pay

template AggregatedQuotePending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [(TransportedWarehouseAllocationWithPrice, ContractId LockedTransportCapacity, ContractId LockedInventoryItem)]
  where
    signatory supplier

    controller supplier can
      AggregatedQuotePending_SendQuoteToSeller: ContractId AggregatedQuoteTrigger
        do
          --TODO: check if locks correspond to items

          deliveryItems <- forA items (\((alloc, price), ltc, lii) -> do
            supplierPayment <- create PaymentRequest with
              payer = seller
              payee = supplier
              price = price
            return $ DeliveryPlanItem alloc ltc lii supplierPayment)
          let quoteItems = map (\((alloc, price), tcr, lii) -> PricedWarehouseAllocation alloc.allocation price) items --TODO: fix price (quantity * unitPrice)
          deliveryPlanCid <- create DeliveryPlan with
            items = deliveryItems, ..
          create AggregatedQuoteTrigger with
            items = quoteItems, ..

template AggregatedQuoteTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory supplier

    controller seller can
      AggregatedQuoteTrigger_Execute: ContractId AggregatedQuote
        do
          create AggregatedQuote with ..


-- Aggregated quote ready for sending to buyer and adding the margin before that
template AggregatedQuote
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory seller
    controller seller can
      AggregatedQuote_AddMargin: (ContractId Quote, ContractId DeliveryAndPaymentPlan)
        with
          margin: Decimal
        do
          let itemsWithMargin = map (\i -> i with price = i.price * (1.0 + margin)) items
          let totalPrice = foldl (\price i -> price + i.price) 0.0 itemsWithMargin
          deliveryPlan <- fetch deliveryPlanCid
          deliveryItems <- forA deliveryPlan.items (\item -> do
              let pricedItemOpt = find
                    (\i -> i.allocation.productName == item.allocation.allocation.productName && i.allocation.warehouse == item.allocation.allocation.warehouse)
                    itemsWithMargin
              assertMsg ("Corresponding quote item not found for " <> item.allocation.allocation.productName) $ isSome pricedItemOpt
              let pricedItem = fromSome pricedItemOpt

              req <- create PaymentRequest with
                price = pricedItem.price
                payer = buyer
                payee = seller
              return DeliveryAndPaymentPlanItem with
                allocation = item.allocation
                transportCapacityLockCid = item.transportCapacityLockCid
                buyerPaymentRequestCid = req
                supplierPaymentRequestCid = item.supplierPaymentRequestCid
                lockedInventoryItemCid = item.lockedInventoryItemCid
            )
          deliveryPlanCid <- create DeliveryAndPaymentPlan with
            items = deliveryItems, ..
          quote <- create Quote with
                  items = itemsWithMargin, ..
          return (quote, deliveryPlanCid)


data DeliveryPlanItem = DeliveryPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    supplierPaymentRequestCid: ContractId PaymentRequest
  deriving (Eq, Show)

template DeliveryPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryPlanItem]
  where
    signatory supplier
    observer seller

data DeliveryAndPaymentPlanItem = DeliveryAndPaymentPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
  deriving (Eq, Show)

template DeliveryAndPaymentPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryAndPaymentPlanItem]
  where
    signatory seller

    controller seller can
      DeliveryPlan_Start: [ContractId DeliveryInstruction]
        do
          forA items (\item -> create DeliveryInstruction with
              productName = item.allocation.allocation.productName
              warehouse = item.allocation.allocation.warehouse
              quantity = item.allocation.allocation.quantity
              transportCompany = item.allocation.transportCompany
              transportCapacityLockCid = item.transportCapacityLockCid
              lockedInventoryItemCid = item.lockedInventoryItemCid
              buyerPaymentRequestCid = item.buyerPaymentRequestCid
              supplierPaymentRequestCid = item.supplierPaymentRequestCid
              deliveryDate = item.allocation.deliveryDate, ..
            )

template Quote
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    totalPrice: Decimal
  where
    signatory seller
    observer buyer

    controller buyer can
      Quote_Accept: ContractId QuoteAccepted
        do
          create QuoteAccepted with ..

template QuoteAccepted
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
  where
    signatory seller

    controller seller can
      QuoteAccepted_StartDelivery: [ContractId DeliveryInstruction]
        do
          exercise deliveryPlanCid DeliveryPlan_Start

template DeliveryInstruction
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  where
    signatory seller
    observer transportCompany

    controller transportCompany can
      DeliveryInstruction_PickUp: ContractId PickUpRequest
        do
          now <- getTime
          let today = toDateUTC now
          assertMsg ("Pick up should happen on the delivery date: " <> show deliveryDate) $ (today == deliveryDate)
          create PickUpRequest with ..

template PickUpRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer warehouse

    controller warehouse can
      PickUpRequest_Accept: ContractId Delivery
        do
          lockedInventoryItem <- fetch lockedInventoryItemCid
          assertMsg "aaa" $ lockedInventoryItem.productName == productName
          assertMsg "bbb" $ lockedInventoryItem.quantity >= quantity
          archive lockedInventoryItemCid
          create Delivery with
            warehousePaymentRequestCid = lockedInventoryItem.warehousePaymentRequestCid, ..

-- Request for a payment from the payee.
template PaymentRequest
  with
    payer: Party
    payee: Party
    price: Decimal
  where
    signatory payee
    observer payer

    controller payer can
      PaymentRequest_Pay: ContractId PaymentObligation
        do
          create PaymentObligation with ..

-- Represents the payers obligation to pay the specified price to the payee (off-ledger)
template PaymentObligation
  with
    payer: Party
    payee: Party
    price: Decimal
  where
    signatory payer, payee
    agreement show payer <> " agrees to pay " <> show price <> " currency units to " <> show payee

-- The Delivery contract is a notification for the buyer that an item is
-- transported to the destination and it can start the payment for it.
template Delivery
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    quantity: Int
    warehouse: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse, transportCompany
    observer buyer

    controller buyer can
      Delivery_Acknowledge: ContractId DeliveryComplete
        do
          -- Payment must happen in a choice which is not visible to warehouse and transportCompany
          create DeliveryComplete with ..

-- Template to indicate that the delivery was acknowledged and the seller can start the payouts.
template DeliveryComplete
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory buyer
    observer seller

    controller seller can
      DeliveryComplete_Accept: ContractId DeliveryPayment
        do
          obligation <- exercise buyerPaymentRequestCid PaymentRequest_Pay
          supplierPaymentRequest <- fetch supplierPaymentRequestCid
          let supplier = supplierPaymentRequest.payee
          -- Payments to the warehouse and transportCompany should not be visible to buyer
          create DeliveryPayment with ..

-- Facilitates to create the payment obligations of the seller.
-- This contract is not visible to buyer, therefore payment to supplier can happen
template DeliveryPayment
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    seller: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory seller

    controller supplier can
      DeliveryPayment_Accept: (ContractId DeliverySupplierPayment, ContractId PaymentObligation)
        do
          so <- exercise supplierPaymentRequestCid PaymentRequest_Pay
          payment <- create DeliverySupplierPayment with ..
          return (payment, so)

-- Facilitates to create the payment obligations of the supplier.
-- This contract is not visible to seller, therefore payment to warehouse can happen
template DeliverySupplierPayment
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory supplier

    controller supplier can
      DeliverySupplierPayment_Pay: (ContractId PaymentObligation, ContractId PaymentObligation)
        do
          wo <- exercise warehousePaymentRequestCid PaymentRequest_Pay
          to <- exercise transportCapacityLockCid LockedTransportCapacity_ReleaseAndPay
          return (wo, to)

data CalculationResult =
  CalculationResult {
    productName: Text;
    quantity: Int;
    warehouse: Party;
    transportCompany: Party
  } deriving (Eq, Show)

data CombinedQuote =
  CombinedQuote {
    maxDeliveredQuantity: Int;
    combinedUnitPrice: Decimal;
    transportQuoteCid: ContractId TransportQuote;
    inventoryQuoteCid: ContractId InventoryQuote;
    allocation: WarehouseAllocationWithDates
  } deriving (Eq, Show)

data ProportionalQuote =
  ProportionalQuote {
    quantity: Int;
    transportQuoteCid: ContractId TransportQuote;
    inventoryQuoteCid: ContractId InventoryQuote;
    allocation: WarehouseAllocationWithDates
  } deriving (Eq, Show)

bestPriceDelivery: [ContractId TransportQuote] ->
                  [ContractId InventoryQuote] ->
                  [WarehouseAllocationWithDates]->
                  Update [ProportionalQuote]
bestPriceDelivery transportQuoteCids inventoryQuoteCids itemsToDeliver =
  do
    transportQuotes <- forA transportQuoteCids fetch
    let transportQuotesWithCid = zip transportQuotes transportQuoteCids
    inventoryQuotes <- forA inventoryQuoteCids fetch
    let inventoryQuotesWithCid = zip inventoryQuotes inventoryQuoteCids
    let bestQuotes = map (\item  ->
          let productName = item.allocation.productName
              transportQuotesForProduct = filter (\quoteWithCid -> (fst (fst quoteWithCid).item).productName == productName) transportQuotesWithCid
              combinedQuotes = map (\transportQuoteWithCid ->
                  let transportQuoteCid = snd transportQuoteWithCid
                      transportQuote = fst transportQuoteWithCid
                      transportQuantity = (snd transportQuote.item).transportableQuantity
                      transportUnitPrice = (snd transportQuote.item).price / (intToDecimal transportQuantity)
                      matchingInventoryQuote = listToOptional $ filter (\quoteWithCid -> (fst quoteWithCid).productName == productName && (fst quoteWithCid).warehouse == (fst transportQuote.item).warehouse) inventoryQuotesWithCid

                      combinedQuote = fmap (\ inventoryQuoteWithCid ->
                          let inventoryQuoteCid = snd inventoryQuoteWithCid
                              inventoryQuote = fst inventoryQuoteWithCid
                              warehouseQuantity = inventoryQuote.quantity
                              maxDeliveredQuantity = min warehouseQuantity transportQuantity
                              warehouseUnitPrice = inventoryQuote.price / (intToDecimal warehouseQuantity)
                              combinedUnitPrice = warehouseUnitPrice + transportUnitPrice
                          in CombinedQuote with maxDeliveredQuantity; combinedUnitPrice; transportQuoteCid; inventoryQuoteCid; allocation = item
                          ) matchingInventoryQuote
                  in optionalToList combinedQuote
                  ) transportQuotesForProduct
              bestQuotes = bestQuotesForQuantity item.allocation.quantity (concat combinedQuotes)
          in bestQuotes
          ) itemsToDeliver
    return (concat bestQuotes)

data SummedQuotes =
  SummedQuotes {
    sumSoFar: Int;
    quotesSoFar: [ProportionalQuote]
  } deriving (Eq, Show)

bestQuotesForQuantity: Int ->
                  [CombinedQuote] ->
                  [ProportionalQuote]
bestQuotesForQuantity quantity combinedQuotes =
  let sortedQuotes = sortOn combinedUnitPrice combinedQuotes
      quotesForQuantity = foldl (\ summedQuotes actQuote ->
          let missing = quantity - summedQuotes.sumSoFar
              toBeAdded = min missing actQuote.maxDeliveredQuantity
              quotes = summedQuotes.quotesSoFar
              newQuote = ProportionalQuote with quantity = toBeAdded; transportQuoteCid = actQuote.transportQuoteCid; inventoryQuoteCid = actQuote.inventoryQuoteCid; allocation = actQuote.allocation
              newQuotes = if (missing > 0) then newQuote :: quotes else quotes
              next = SummedQuotes with sumSoFar = toBeAdded + summedQuotes.sumSoFar; quotesSoFar = newQuotes
          in next
          ) (SummedQuotes with sumSoFar = 0; quotesSoFar = []) sortedQuotes
  in quotesForQuantity.quotesSoFar
