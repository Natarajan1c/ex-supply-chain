--
-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
--

daml 1.2
module DA.RefApps.SupplyChain.Main where

import DA.List
import DA.Date
import DA.Optional

import DA.RefApps.SupplyChain.Types

-- Relationships

template BuyerSellerRelationshipInvitation
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer
    controller seller can
      BuyerSellerRelationshipInvitation_Accept: ContractId BuyerSellerRelationship
        do
          create $ BuyerSellerRelationship with ..

template BuyerSellerRelationship
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer, seller
    controller buyer can
      nonconsuming BuyerSellerRelationship_SendQuoteRequest: ContractId QuoteRequest
        with
          products: [OrderedProduct]
        do
          create $ QuoteRequest with ..

-- Quote request

template QuoteRequest
  with
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory buyer
    controller seller can
      QuoteRequest_Accept: ContractId QuoteRequestAccepted
        do
          create QuoteRequestAccepted with
            quoteId = self, ..

template QuoteRequestAccepted
  with
    quoteId: ContractId QuoteRequest -- opaque id of the workflow initiated by this QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory seller
    controller seller can
      QuoteRequestAccepted_SendToSupplier : ContractId QuoteRequestSupplyInvitation
        with
          supplier: Party
        do
          create QuoteRequestSupplyInvitation with supplier = supplier, ..

template QuoteRequestSupplyInvitation
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller
    controller supplier can
      QuoteRequestSupplyInvitation_Accept : ContractId SupplyRequest
        do
          create SupplyRequest with ..


-- Supplier can initiate the inventory reservation and transport quote collection with this template
template SupplyRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller, supplier
    controller supplier can
      SupplyRequest_StartPriceCollection: (ContractId TransportQuoteRequestPending, [ContractId InventoryQuoteRequest], [ContractId TransportQuoteRequest])
        with
          warehouses: [Party]
          transportCompanies: [Party]
        do
          (invRequests, allocations) <- fmap (unzip . concat) $ forA warehouses
              (\w -> forA products
                (\product -> do
                  req <- create InventoryQuoteRequest with
                    warehouse = w, ..
                  let wa = WarehouseAllocationWithDates (WarehouseAllocation product.productName w product.quantity) product.deliveryFrom product.deliveryTo
                  return (req, wa)))
          quoteRequests <- fmap concat $ forA transportCompanies
              (\tc -> forA allocations
                (\allocations ->
                  create TransportQuoteRequest with
                    transportCompany = tc
                    item = allocations, ..))

          pending <- create TransportQuoteRequestPending with
            items = allocations, ..
          return (pending, invRequests, quoteRequests)

-- Inventory

template InventoryItem
  with
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier
    controller supplier can
      InventoryItem_SplitAndLock: (ContractId InventoryItem, ContractId LockedInventoryItem)
        with
          reservation: ContractId InventoryQuote
          quantitiesToLock: [Int]
          quoteId: ContractId QuoteRequest
        do
          let quantityToLock = head quantitiesToLock -- TODO: cycle instead
          let remainingQuantity = quantity - quantityToLock
          assertMsg "Non-positive remaining quantity." $ remainingQuantity > 0

          this2 <- create InventoryItem with quantity = remainingQuantity, ..

          warehousePaymentRequestCid <- create PaymentRequest with
            payer = supplier
            payee = warehouse
            price = unitPrice * intToDecimal quantityToLock

          locked <- create LockedInventoryItem with quantity = head quantitiesToLock, .. --TODO
          return (this2, locked)

template LockedInventoryItem
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse
    observer supplier

template InventoryQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    product: OrderedProduct
  where
    signatory supplier

    controller warehouse can
      InventoryQuoteRequest_Accept: ContractId InventoryQuote
        with
          inventoryItemCid: ContractId InventoryItem
        do
          item <- fetch inventoryItemCid
          let reservedQuantity = min item.quantity product.quantity
          create InventoryQuote with
            quantity = reservedQuantity
            price = item.unitPrice * intToDecimal reservedQuantity
            productName = product.productName, ..

template InventoryQuote
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    price: Decimal
  where
    signatory warehouse

-- Supplier

-- template InventoryLockingBotTrigger
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     whatToLock: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       WarehouseInvetoryLockingBotTrigger_Lock: (ContractId RequestDeliveryProposal, [ContractId LockedInventoryItem])
--         with
--           inventoryCids : [ContractId InventoryItem]
--         do
--           inventory <- forA inventoryCids fetch
--           let inventoryPair = zip inventoryCids inventory
--           lockResult <- forA whatToLock (\alloc -> do
--               let inventoryItem = fromSome $ find (\(cid, i) -> i.productName == alloc.allocation.productName && i.warehouse == alloc.allocation.warehouse) inventoryPair
--               exercise (fst inventoryItem) $ InventoryItem_SplitAndLock with
--                                                 quantityToLock = alloc.allocation.quantity
--             )
--           let (_, lockedCids) = unzip lockResult
--           proposal <- create RequestDeliveryProposal with
--                   items = whatToLock, ..
--           return (proposal, lockedCids)

-- template RequestDeliveryProposal
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     items: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       RequestDeliveryProposal_RequestTransportQuote: (ContractId TransportQuoteRequestPending, [ContractId TransportQuoteRequest])
--         with
--           transportCompanies: [Party]
--         do
--           qRequests <- forA transportCompanies \tC -> create TransportQuoteRequest with
--                                                   transportCompany = tC
--                                                   supplier = supplier
--                                                   items = items
--           pending <- create TransportQuoteRequestPending with ..
--           return (pending, qRequests)

data TransportQuoteItem = TransportQuoteItem with
    transportableQuantity: Int
    price: Decimal -- total price corresponding to transportableQuantity
    deliveryDate: Date
  deriving (Eq, Show)

template TransportQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    buyer: Party
    buyerAddress: Text
    item: WarehouseAllocationWithDates
  where
    signatory supplier
    controller transportCompany can
      TransportQuoteRequest_Accept: ContractId TransportQuote
        with
          quoteItem: TransportQuoteItem
        do
          create TransportQuote with item = (item.allocation, quoteItem), ..

template TransportQuote
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: (WarehouseAllocation, TransportQuoteItem)
  where
    signatory supplier, transportCompany

    controller supplier can
      TransportQuote_Lock: () --ContractId LockedTransportCapacity
        with
          quantities: [Int]
        do
          return ()

template TransportQuoteRequestPending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      -- Supplier waits no more, bot collects available TransportQuote-s
      TransportQuoteRequestPending_ChooseTransport: ContractId ChooseTransportBotTrigger
        do
          create ChooseTransportBotTrigger with ..

template ChooseTransportBotTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      ChooseTransportBotTrigger_Proceed: (ContractId AggregatedQuotePending, [ContractId LockedTransportCapacity], [ContractId LockedInventoryItem])
        with
          quoteCids: [ContractId TransportQuote]
          reservedInventoryItemCids: [ContractId InventoryQuote]
          inventoryItemCids: [ContractId InventoryItem]
        do
          -- do the calculation here, which is the best transport quote?
          let bestQuoteCid = head quoteCids
          bestQuote <- fetch bestQuoteCid
          -- lockReq <- create TransportCapacityLockRequest with
          --         transportCompany = bestQuote.transportCompany
          --         supplier = bestQuote.supplier
          --         item = (head items).allocation -- TODO fill out
          --         deliveryDate = (head items).deliveryFrom -- TODO

          let price = (snd bestQuote.item).price --TODO: proper map
          let deliveryDate = (snd bestQuote.item).deliveryDate  --TODO: proper map
          let deliveryItems = map (\item -> (TransportedWarehouseAllocation item.allocation bestQuote.transportCompany deliveryDate, price)) items --TODO calculate prices based on quantity
          aggregated <- create AggregatedQuotePending with
                  items = zip3 deliveryItems [] [], ..
          return (aggregated, [], [])

template LockedTransportCapacity
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: WarehouseAllocation -- TODO add Address!! down from TransportQuoteRequest
    deliveryDate: Date
    transportPaymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer supplier

    controller supplier can
      LockedTransportCapacity_ReleaseAndPay: ContractId PaymentObligation
        do
          exercise transportPaymentRequestCid PaymentRequest_Pay

template AggregatedQuotePending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [(TransportedWarehouseAllocationWithPrice, ContractId LockedTransportCapacity, ContractId LockedInventoryItem)]
  where
    signatory supplier

    controller supplier can
      AggregatedQuotePending_SendQuoteToSeller: ContractId AggregatedQuoteTrigger
        do
          --TODO: check if locks correspond to items

          deliveryItems <- forA items (\((alloc, price), ltc, lii) -> do
            supplierPayment <- create PaymentRequest with
              payer = seller
              payee = supplier
              price = price
            return $ DeliveryPlanItem alloc ltc lii supplierPayment)
          let quoteItems = map (\((alloc, price), tcr, lii) -> PricedWarehouseAllocation alloc.allocation price) items --TODO: fix price (quantity * unitPrice)
          deliveryPlanCid <- create DeliveryPlan with
            items = deliveryItems, ..
          create AggregatedQuoteTrigger with
            items = quoteItems, ..

template AggregatedQuoteTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory supplier

    controller seller can
      AggregatedQuoteTrigger_Execute: ContractId AggregatedQuote
        do
          create AggregatedQuote with ..


-- Aggregated quote ready for sending to buyer and adding the margin before that
template AggregatedQuote
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory seller
    controller seller can
      AggregatedQuote_AddMargin: (ContractId Quote, ContractId DeliveryAndPaymentPlan)
        with
          margin: Decimal
        do
          let itemsWithMargin = map (\i -> i with price = i.price * (1.0 + margin)) items
          let totalPrice = foldl (\price i -> price + i.price) 0.0 itemsWithMargin
          deliveryPlan <- fetch deliveryPlanCid
          deliveryItems <- forA deliveryPlan.items (\item -> do
              let pricedItemOpt = find
                    (\i -> i.allocation.productName == item.allocation.allocation.productName && i.allocation.warehouse == item.allocation.allocation.warehouse)
                    itemsWithMargin
              assertMsg ("Corresponding quote item not found for " <> item.allocation.allocation.productName) $ isSome pricedItemOpt
              let pricedItem = fromSome pricedItemOpt

              req <- create PaymentRequest with
                price = pricedItem.price
                payer = buyer
                payee = seller
              return DeliveryAndPaymentPlanItem with
                allocation = item.allocation
                transportCapacityLockCid = item.transportCapacityLockCid
                buyerPaymentRequestCid = req
                supplierPaymentRequestCid = item.supplierPaymentRequestCid
                lockedInventoryItemCid = item.lockedInventoryItemCid
            )
          deliveryPlanCid <- create DeliveryAndPaymentPlan with
            items = deliveryItems, ..
          quote <- create Quote with
                  items = itemsWithMargin, ..
          return (quote, deliveryPlanCid)


data DeliveryPlanItem = DeliveryPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    supplierPaymentRequestCid: ContractId PaymentRequest
  deriving (Eq, Show)

template DeliveryPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryPlanItem]
  where
    signatory supplier
    observer seller

data DeliveryAndPaymentPlanItem = DeliveryAndPaymentPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
  deriving (Eq, Show)

template DeliveryAndPaymentPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryAndPaymentPlanItem]
  where
    signatory seller

    controller seller can
      DeliveryPlan_Start: [ContractId DeliveryInstruction]
        do
          forA items (\item -> create DeliveryInstruction with
              productName = item.allocation.allocation.productName
              warehouse = item.allocation.allocation.warehouse
              quantity = item.allocation.allocation.quantity
              transportCompany = item.allocation.transportCompany
              transportCapacityLockCid = item.transportCapacityLockCid
              lockedInventoryItemCid = item.lockedInventoryItemCid
              buyerPaymentRequestCid = item.buyerPaymentRequestCid
              supplierPaymentRequestCid = item.supplierPaymentRequestCid
              deliveryDate = item.allocation.deliveryDate, ..
            )

template Quote
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    totalPrice: Decimal
  where
    signatory seller
    observer buyer

    controller buyer can
      Quote_Accept: ContractId QuoteAccepted
        do
          create QuoteAccepted with ..

template QuoteAccepted
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
  where
    signatory seller

    controller seller can
      QuoteAccepted_StartDelivery: [ContractId DeliveryInstruction]
        do
          exercise deliveryPlanCid DeliveryPlan_Start

template DeliveryInstruction
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  where
    signatory seller
    observer transportCompany

    controller transportCompany can
      DeliveryInstruction_PickUp: ContractId PickUpRequest
        do
          now <- getTime
          let today = toDateUTC now
          assertMsg ("Pick up should happen on the delivery date: " <> show deliveryDate) $ (today == deliveryDate)
          create PickUpRequest with ..

template PickUpRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer warehouse

    controller warehouse can
      PickUpRequest_Accept: ContractId Delivery
        do
          lockedInventoryItem <- fetch lockedInventoryItemCid
          assertMsg "aaa" $ lockedInventoryItem.productName == productName
          assertMsg "bbb" $ lockedInventoryItem.quantity >= quantity
          archive lockedInventoryItemCid
          create Delivery with
            warehousePaymentRequestCid = lockedInventoryItem.warehousePaymentRequestCid, ..

-- Request for a payment from the payee.
template PaymentRequest
  with
    payer: Party
    payee: Party
    price: Decimal
  where
    signatory payee
    observer payer

    controller payer can
      PaymentRequest_Pay: ContractId PaymentObligation
        do
          create PaymentObligation with ..

-- Represents the payers obligation to pay the specified price to the payee (off-ledger)
template PaymentObligation
  with
    payer: Party
    payee: Party
    price: Decimal
  where
    signatory payer, payee
    agreement show payer <> " agrees to pay " <> show price <> " currency units to " <> show payee

-- The Delivery contract is a notification for the buyer that an item is
-- transported to the destination and it can start the payment for it.
template Delivery
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    quantity: Int
    warehouse: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse, transportCompany
    observer buyer

    controller buyer can
      Delivery_Acknowledge: ContractId DeliveryComplete
        do
          -- Payment must happen in a choice which is not visible to warehouse and transportCompany
          create DeliveryComplete with ..

-- Template to indicate that the delivery was acknowledged and the seller can start the payouts.
template DeliveryComplete
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    buyerPaymentRequestCid: ContractId PaymentRequest
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory buyer
    observer seller

    controller seller can
      DeliveryComplete_Accept: ContractId DeliveryPayment
        do
          obligation <- exercise buyerPaymentRequestCid PaymentRequest_Pay
          supplierPaymentRequest <- fetch supplierPaymentRequestCid
          let supplier = supplierPaymentRequest.payee
          -- Payments to the warehouse and transportCompany should not be visible to buyer
          create DeliveryPayment with ..

-- Facilitates to create the payment obligations of the seller.
-- This contract is not visible to buyer, therefore payment to supplier can happen
template DeliveryPayment
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    seller: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory seller

    controller supplier can
      DeliveryPayment_Accept: (ContractId DeliverySupplierPayment, ContractId PaymentObligation)
        do
          so <- exercise supplierPaymentRequestCid PaymentRequest_Pay
          payment <- create DeliverySupplierPayment with ..
          return (payment, so)

-- Facilitates to create the payment obligations of the supplier.
-- This contract is not visible to seller, therefore payment to warehouse can happen
template DeliverySupplierPayment
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    supplierPaymentRequestCid: ContractId PaymentRequest
    warehousePaymentRequestCid: ContractId PaymentRequest
  where
    signatory supplier

    controller supplier can
      DeliverySupplierPayment_Pay: (ContractId PaymentObligation, ContractId PaymentObligation)
        do
          wo <- exercise warehousePaymentRequestCid PaymentRequest_Pay
          to <- exercise transportCapacityLockCid LockedTransportCapacity_ReleaseAndPay
          return (wo, to)
