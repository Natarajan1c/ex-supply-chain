-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module DA.RefApps.SupplyChain.Main where

import DA.List
import DA.Date
import DA.Optional

-- Relationships

template BuyerSellerRelationshipInvitation
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer
    controller seller can
      BuyerSellerRelationshipInvitation_Accept: ContractId BuyerSellerRelationship
        do
          create $ BuyerSellerRelationship with ..

template BuyerSellerRelationship
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer, seller
    controller buyer can
      nonconsuming BuyerSellerRelationship_SendQuoteRequest: ContractId QuoteRequest
        with
          products: [OrderedProduct]
        do
          create $ QuoteRequest with ..

-- Quote request

data OrderedProduct =
  OrderedProduct {
    productName: Text;
    quantity: Int;
    deliveryFrom: Date;
    deliveryTo: Date
  } deriving (Eq, Show)

template QuoteRequest
  with
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory buyer
    controller seller can
      QuoteRequest_Accept: ContractId QuoteRequestAccepted
        do
          create QuoteRequestAccepted with ..

template QuoteRequestAccepted
  with
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory seller
    controller seller can
      QuoteRequestAccepted_SendToSupplier : ContractId QuoteRequestSupplyInvitation
        with
          supplier: Party
        do
          create QuoteRequestSupplyInvitation with supplier = supplier, ..

template QuoteRequestSupplyInvitation
  with
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller
    controller supplier can
      QuoteRequestSupplyInvitation_Accept : ContractId SupplyRequest
        do
          create SupplyRequest with ..

data WarehouseAllocation = WarehouseAllocation with
    productName: Text
    warehouse: Party
    quantity: Int
  deriving (Eq, Show)

data WarehouseAllocationWithDates = WarehouseAllocationWithDates with
    allocation: WarehouseAllocation
    deliveryFrom: Date
    deliveryTo: Date
  deriving (Eq, Show)

data TransportedWarehouseAllocation = TransportedWarehouseAllocation with
    allocation: WarehouseAllocation
    transportCompany: Party
    deliveryDate: Date
  deriving (Eq, Show)

data PricedWarehouseAllocation = PricedWarehouseAllocation with
    allocation: WarehouseAllocation
    price: Decimal
  deriving (Eq, Show)


type TransportedWarehouseAllocationWithPrice = (TransportedWarehouseAllocation, Decimal)
type ProductWithQuantity = (Text, Int)

template SupplyRequest
  with
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller, supplier
    controller supplier can
      -- User chooses this option
      SupplyRequest_LockProducts: ContractId InventoryLockingBotTrigger
        with
          whatToLock: [WarehouseAllocation]
        do
          allocWithDates <- forA whatToLock (\alloc -> do
              let correspondingOrder = find (\o -> o.productName == alloc.productName) products
              assertMsg ("Locked product was not ordered: " <> alloc.productName) $ isSome correspondingOrder
              let order = fromSome correspondingOrder
              return $ WarehouseAllocationWithDates alloc order.deliveryFrom order.deliveryTo
            )
          create InventoryLockingBotTrigger with
            whatToLock = allocWithDates, ..

-- Inventory

template InventoryItem
  with
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier
    controller supplier can
      InventoryItem_SplitAndLock: (ContractId InventoryItem, ContractId LockedInventoryItem)
        with
          quantityToLock: Int
        do
          let remainingQuantity = quantity - quantityToLock
          assertMsg "Non-positive remaining quantity." $ remainingQuantity > 0
          this2 <- create InventoryItem with quantity = remainingQuantity, ..
          locked <- create LockedInventoryItem with quantity = quantityToLock, ..
          return (this2, locked)

template LockedInventoryItem
  with
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier

    controller warehouse can
      LockedInventoryItem_PickUp: Optional (ContractId LockedInventoryItem)
        with
          quantityToPick: Int
        do
          assertMsg "To big quantity" $ quantityToPick <= quantity
          if (quantityToPick == quantity) then return None
          else Some <$> create LockedInventoryItem with
            quantity = quantity - quantityToPick, ..

-- Supplier

template InventoryLockingBotTrigger
  with
    supplier: Party
    buyer: Party
    seller: Party
    whatToLock: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      WarehouseInvetoryLockingBotTrigger_Lock: (ContractId RequestDeliveryProposal, [ContractId LockedInventoryItem])
        with
          inventoryCids : [ContractId InventoryItem]
        do
          inventory <- forA inventoryCids fetch
          let inventoryPair = zip inventoryCids inventory
          lockResult <- forA whatToLock (\alloc -> do
              let inventoryItem = fromSome $ find (\(cid, i) -> i.productName == alloc.allocation.productName && i.warehouse == alloc.allocation.warehouse) inventoryPair
              exercise (fst inventoryItem) $ InventoryItem_SplitAndLock with
                                                quantityToLock = alloc.allocation.quantity
            )
          let (_, lockedCids) = unzip lockResult
          proposal <- create RequestDeliveryProposal with
                  items = whatToLock, ..
          return (proposal, lockedCids)

template RequestDeliveryProposal
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      RequestDeliveryProposal_RequestTransportQuote: (ContractId TransportQuoteRequestPending, [ContractId TransportQuoteRequest])
        with
          transportCompanies: [Party]
        do
          qRequests <- forA transportCompanies \tC -> create TransportQuoteRequest with
                                                  transportCompany = tC
                                                  supplier = supplier
                                                  items = items
          pending <- create TransportQuoteRequestPending with ..
          return (pending, qRequests)

data TransportQuoteItem = TransportQuoteItem with
    transportableQuantity: Int
    price: Decimal -- total price corresponding to transportableQuantity
    deliveryDate: Date
  deriving (Eq, Show)

template TransportQuoteRequest
  with
    transportCompany: Party
    supplier: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller transportCompany can
      TransportQuoteRequest_Accept: ContractId TransportQuote
        with
          quoteItems: [TransportQuoteItem]
        do
          assertMsg "All ordered items must have a corresponding quote item" $ (length items) == (length quoteItems)
          let zipped = zip (map (\i -> i.allocation) items) quoteItems
          create TransportQuote with items = zipped, ..

template TransportQuote
  with
    transportCompany: Party
    supplier: Party
    items: [(WarehouseAllocation, TransportQuoteItem)]
  where
    signatory supplier, transportCompany

template TransportQuoteRequestPending
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      -- Supplier waits no more, bot collects available TransportQuote-s
      TransportQuoteRequestPending_ChooseTransport: ContractId ChooseTransportBotTrigger
        do
          create ChooseTransportBotTrigger with ..

template ChooseTransportBotTrigger
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      ChooseTransportBotTrigger_Proceed: (ContractId AggregatedQuotePending, [ContractId TransportCapacityLockRequest])
        with
          quoteCids: [ContractId TransportQuote]
        do
          -- do the calculation here, which is the best transport quote?
          let bestQuoteCid = head quoteCids
          bestQuote <- fetch bestQuoteCid
          lockReq <- create TransportCapacityLockRequest with
                  transportCompany = bestQuote.transportCompany
                  supplier = bestQuote.supplier
                  item = (head items).allocation -- TODO fill out
                  deliveryDate = (head items).deliveryFrom -- TODO

          let price = (snd (head bestQuote.items)).price --TODO: proper map
          let deliveryDate = (snd (head bestQuote.items)).deliveryDate  --TODO: proper map
          let deliveryItems = map (\item -> (TransportedWarehouseAllocation item.allocation bestQuote.transportCompany deliveryDate, price)) items --TODO calculate prices based on quantity
          aggregated <- create AggregatedQuotePending with
                  items = deliveryItems, ..
          return (aggregated, [lockReq])

template TransportCapacityLockRequest
  with
    transportCompany: Party
    supplier: Party
    item: WarehouseAllocation -- TODO add Address!! down from TransportQuoteRequest
    deliveryDate: Date
  where
    signatory supplier
    controller transportCompany can
      TransportCapacityLockRequest_Accept: ContractId TransportCapacityLock
        do
          create TransportCapacityLock with ..

template TransportCapacityLock
  with
    transportCompany: Party
    supplier: Party
    item: WarehouseAllocation -- TODO add Address!! down from TransportQuoteRequest
    deliveryDate: Date
  where
    signatory transportCompany
    observer supplier

template AggregatedQuotePending
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [TransportedWarehouseAllocationWithPrice]
  where
    signatory supplier

    controller supplier can
      AggregatedQuotePending_SendQuoteToSeller: ContractId AggregatedQuoteTrigger
        with
          --TODO check if this should be collected with bot. Also check if there is a need for manual "send quote to seller" step
          transportCapacityLockCids: [ContractId TransportCapacityLock]
        do
          --TODO: check if locks correspond to items
          let transportCapacityLockCid = head transportCapacityLockCids
              deliveryItems = map (\(alloc, _price) -> DeliveryPlanItem alloc transportCapacityLockCid alloc.deliveryDate) items
              quoteItems = map (\(alloc, price) -> PricedWarehouseAllocation alloc.allocation price) items --TODO: fix price (quantity * unitPrice)
          deliveryPlanCid <- create DeliveryPlan with
            items = deliveryItems, ..
          create AggregatedQuoteTrigger with
            items = quoteItems, ..

template AggregatedQuoteTrigger
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory supplier

    controller seller can
      AggregatedQuoteTrigger_Execute: ContractId AggregatedQuote
        do
          create AggregatedQuote with ..


template AggregatedQuote
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory seller
    controller seller can
      AggregatedQuote_AddMargin: ContractId Quote
        with
          margin: Int
        do
          let itemsWithMargin = items -- TODO Add price and margin
          deliveryPlan <- fetch deliveryPlanCid
          deliveryItems <- forA deliveryPlan.items (\item -> do
              req <- create PaymentRequest with
                price = (head itemsWithMargin).price, .. --FIXME
              return DeliveryAndPaymentPlanItem with
                allocation = item.allocation
                transportCapacityLockCid = item.transportCapacityLockCid
                paymentRequestCid = req
                deliveryDate = item.deliveryDate
            )
          deliveryPlanCid <- create DeliveryAndPaymentPlan with
            items = deliveryItems, ..
          create Quote with
                  items = itemsWithMargin, ..
                  -- TODO Actual items on quote should be (Product - Price - Quantity) /not aggregated/


data DeliveryPlanItem = DeliveryPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId TransportCapacityLock
    deliveryDate: Date
  deriving (Eq, Show)

template DeliveryPlan
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryPlanItem]
  where
    signatory supplier
    observer seller

data DeliveryAndPaymentPlanItem = DeliveryAndPaymentPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId TransportCapacityLock
    paymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  deriving (Eq, Show)

template DeliveryAndPaymentPlan
  with
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryAndPaymentPlanItem]
  where
    signatory seller

    controller seller can
      DeliveryPlan_Start: [ContractId DeliveryInstruction]
        do
          forA items (\item -> create DeliveryInstruction with
              productName = item.allocation.allocation.productName
              warehouse = item.allocation.allocation.warehouse
              quantity = item.allocation.allocation.quantity
              transportCompany = item.allocation.transportCompany
              transportCapacityLockCid = item.transportCapacityLockCid
              paymentRequestCid = item.paymentRequestCid
              deliveryDate = item.deliveryDate, ..
            )

template Quote
  with
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    --TODO: do we need the grandtotal?
  where
    signatory seller
    observer buyer

    controller buyer can
      Quote_Accept: ContractId QuoteAccepted
        do
          create QuoteAccepted with ..

template QuoteAccepted
  with
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
  where
    signatory seller

    controller seller can
      QuoteAccepted_StartDelivery: [ContractId DeliveryInstruction]
        do
          exercise deliveryPlanCid DeliveryPlan_Start

template DeliveryInstruction
  with
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId TransportCapacityLock
    paymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  where
    signatory seller
    observer transportCompany

    controller transportCompany can
      DeliveryInstruction_PickUp: ContractId PickUpRequest
        do
          now <- getTime
          let today = toDateUTC now
          assertMsg ("Pick up should happen on the delivery date: " <> show deliveryDate) $ (today == deliveryDate)
          create PickUpRequest with ..

template PickUpRequest
  with
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId TransportCapacityLock
    paymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer warehouse

    controller warehouse can
      PickUpRequest_Accept: ContractId Delivery
        with lockedInventoryItemCid: ContractId LockedInventoryItem
        do
          lockedInventoryItem <- fetch lockedInventoryItemCid
          assertMsg "aaa" $ lockedInventoryItem.productName == productName
          assertMsg "bbb" $ lockedInventoryItem.quantity >= quantity
          exercise lockedInventoryItemCid $ LockedInventoryItem_PickUp quantity
          create Delivery with ..

template PaymentRequest
  with
    buyer: Party
    seller: Party
    price: Decimal
  where
    signatory seller
    observer buyer

    controller buyer can
      PaymentRequest_Pay: ()
        do return ()

template Delivery
  with
    buyer: Party
    seller: Party
    productName: Text
    quantity: Int
    warehouse: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId TransportCapacityLock
    paymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse, transportCompany
    observer buyer

    controller buyer can
      Delivery_Pay: ContractId DeliveryAck
        do
          ack <- create DeliveryAck with ..
          exercise paymentRequestCid PaymentRequest_Pay
          return ack

template DeliveryAck
  with
    buyer: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId TransportCapacityLock
  where
    signatory buyer
    observer transportCompany

    controller transportCompany can
      DeliveryAck_ReleaseCapacity: ()
        do
          archive transportCapacityLockCid
