-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module DA.RefApps.SupplyChain.Main where

import DA.List
import DA.Date

import DA.RefApps.SupplyChain.Types

-- Relationships

template BuyerSellerRelationshipInvitation
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer
    controller seller can
      BuyerSellerRelationshipInvitation_Accept: ContractId BuyerSellerRelationship
        do
          create $ BuyerSellerRelationship with ..

template BuyerSellerRelationship
  with
    buyer : Party
    buyerAddress: Text
    seller: Party
  where
    signatory buyer, seller
    controller buyer can
      nonconsuming BuyerSellerRelationship_SendQuoteRequest: ContractId QuoteRequest
        with
          products: [OrderedProduct]
        do
          create $ QuoteRequest with ..

-- Quote request

template QuoteRequest
  with
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory buyer
    controller seller can
      QuoteRequest_Accept: ContractId QuoteRequestAccepted
        do
          create QuoteRequestAccepted with
            quoteId = self, ..

template QuoteRequestAccepted
  with
    quoteId: ContractId QuoteRequest -- opaque id of the workflow initiated by this QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller  : Party
    products: [OrderedProduct]
  where
    signatory seller
    controller seller can
      QuoteRequestAccepted_SendToSupplier : ContractId QuoteRequestSupplyInvitation
        with
          supplier: Party
        do
          create QuoteRequestSupplyInvitation with supplier = supplier, ..

template QuoteRequestSupplyInvitation
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller
    controller supplier can
      QuoteRequestSupplyInvitation_Accept : ContractId SupplyRequest
        do
          create SupplyRequest with ..


-- Supplier can initiate the inventory reservation and transport quote collection with this template
template SupplyRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    buyerAddress: Text
    seller: Party
    supplier: Party
    products: [OrderedProduct]
  where
    signatory seller, supplier
    controller supplier can
      SupplyRequest_StartPriceCollection: (ContractId TransportQuoteRequestPending, [ContractId InventoryQuoteRequest], [ContractId TransportQuoteRequest])
        with
          warehouses: [Party]
          transportCompanies: [Party]
        do
          (invRequests, allocations) <- fmap (unzip . concat) $ forA warehouses
              (\w -> forA products
                (\product -> do
                  req <- create InventoryQuoteRequest with
                    warehouse = w, ..
                  let wa = WarehouseAllocationWithDates (WarehouseAllocation product.productName w product.quantity) product.deliveryFrom product.deliveryTo
                  return (req, wa)))
          quoteRequests <- fmap concat $ forA transportCompanies
              (\tc -> forA allocations
                (\allocations ->
                  create TransportQuoteRequest with
                    transportCompany = tc
                    item = allocations, ..))

          pending <- create TransportQuoteRequestPending with
            items = allocations, ..
          return (pending, invRequests, quoteRequests)

-- Inventory

template InventoryItem
  with
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier
    controller supplier can
      InventoryItem_SplitAndLock: (ContractId InventoryItem, ContractId LockedInventoryItem)
        with
          reservation: ContractId InventoryQuote
          quantitiesToLock: [Int]
          quoteId: ContractId QuoteRequest
        do
          let remainingQuantity = quantity - head quantitiesToLock -- TODO
          assertMsg "Non-positive remaining quantity." $ remainingQuantity > 0
          this2 <- create InventoryItem with quantity = remainingQuantity, ..
          locked <- create LockedInventoryItem with quantity = head quantitiesToLock, .. --TODO
          return (this2, locked)

template LockedInventoryItem
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    unitPrice: Decimal
  where
    signatory warehouse
    observer supplier

template InventoryQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    product: OrderedProduct
  where
    signatory supplier

    controller warehouse can
      InventoryQuoteRequest_Accept: ContractId InventoryQuote
        with
          inventoryItemCid: ContractId InventoryItem
        do
          item <- fetch inventoryItemCid
          let reservedQuantity = min item.quantity product.quantity
          create InventoryQuote with
            quantity = reservedQuantity
            price = item.unitPrice * intToDecimal reservedQuantity
            productName = product.productName, ..

template InventoryQuote
  with
    quoteId: ContractId QuoteRequest
    warehouse: Party
    supplier: Party
    productName: Text
    quantity: Int
    price: Decimal
  where
    signatory warehouse

-- Supplier

-- template InventoryLockingBotTrigger
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     whatToLock: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       WarehouseInvetoryLockingBotTrigger_Lock: (ContractId RequestDeliveryProposal, [ContractId LockedInventoryItem])
--         with
--           inventoryCids : [ContractId InventoryItem]
--         do
--           inventory <- forA inventoryCids fetch
--           let inventoryPair = zip inventoryCids inventory
--           lockResult <- forA whatToLock (\alloc -> do
--               let inventoryItem = fromSome $ find (\(cid, i) -> i.productName == alloc.allocation.productName && i.warehouse == alloc.allocation.warehouse) inventoryPair
--               exercise (fst inventoryItem) $ InventoryItem_SplitAndLock with
--                                                 quantityToLock = alloc.allocation.quantity
--             )
--           let (_, lockedCids) = unzip lockResult
--           proposal <- create RequestDeliveryProposal with
--                   items = whatToLock, ..
--           return (proposal, lockedCids)

-- template RequestDeliveryProposal
--   with
--     supplier: Party
--     buyer: Party
--     seller: Party
--     items: [WarehouseAllocationWithDates]
--   where
--     signatory supplier
--     controller supplier can
--       RequestDeliveryProposal_RequestTransportQuote: (ContractId TransportQuoteRequestPending, [ContractId TransportQuoteRequest])
--         with
--           transportCompanies: [Party]
--         do
--           qRequests <- forA transportCompanies \tC -> create TransportQuoteRequest with
--                                                   transportCompany = tC
--                                                   supplier = supplier
--                                                   items = items
--           pending <- create TransportQuoteRequestPending with ..
--           return (pending, qRequests)

data TransportQuoteItem = TransportQuoteItem with
    transportableQuantity: Int
    price: Decimal -- total price corresponding to transportableQuantity
    deliveryDate: Date
  deriving (Eq, Show)

template TransportQuoteRequest
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    buyer: Party
    buyerAddress: Text
    item: WarehouseAllocationWithDates
  where
    signatory supplier
    controller transportCompany can
      TransportQuoteRequest_Accept: ContractId TransportQuote
        with
          quoteItem: TransportQuoteItem
        do
          create TransportQuote with item = (item.allocation, quoteItem), ..

template TransportQuote
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: (WarehouseAllocation, TransportQuoteItem)
  where
    signatory supplier, transportCompany

    controller supplier can
      TransportQuote_Lock: () --ContractId LockedTransportCapacity
        with
          quantities: [Int]
        do
          return ()

template TransportQuoteRequestPending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      -- Supplier waits no more, bot collects available TransportQuote-s
      TransportQuoteRequestPending_ChooseTransport: ContractId ChooseTransportBotTrigger
        do
          create ChooseTransportBotTrigger with ..

template ChooseTransportBotTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [WarehouseAllocationWithDates]
  where
    signatory supplier
    controller supplier can
      ChooseTransportBotTrigger_Proceed: (ContractId AggregatedQuotePending, [ContractId LockedTransportCapacity], [ContractId LockedInventoryItem])
        with
          quoteCids: [ContractId TransportQuote]
          reservedInventoryItemCids: [ContractId InventoryQuote]
          inventoryItemCids: [ContractId InventoryItem]
        do
          -- do the calculation here, which is the best transport quote?
          let bestQuoteCid = head quoteCids
          bestQuote <- fetch bestQuoteCid
          -- lockReq <- create TransportCapacityLockRequest with
          --         transportCompany = bestQuote.transportCompany
          --         supplier = bestQuote.supplier
          --         item = (head items).allocation -- TODO fill out
          --         deliveryDate = (head items).deliveryFrom -- TODO

          let price = (snd bestQuote.item).price --TODO: proper map
          let deliveryDate = (snd bestQuote.item).deliveryDate  --TODO: proper map
          let deliveryItems = map (\item -> (TransportedWarehouseAllocation item.allocation bestQuote.transportCompany deliveryDate, price)) items --TODO calculate prices based on quantity
          aggregated <- create AggregatedQuotePending with
                  items = zip3 deliveryItems [] [], ..
          return (aggregated, [], [])

template LockedTransportCapacity
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    supplier: Party
    item: WarehouseAllocation -- TODO add Address!! down from TransportQuoteRequest
    deliveryDate: Date
  where
    signatory transportCompany
    observer supplier

template AggregatedQuotePending
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [(TransportedWarehouseAllocationWithPrice, ContractId LockedTransportCapacity, ContractId LockedInventoryItem)]
  where
    signatory supplier

    controller supplier can
      AggregatedQuotePending_SendQuoteToSeller: ContractId AggregatedQuoteTrigger
        do
          --TODO: check if locks correspond to items
          let deliveryItems = map (\((alloc, _price), tcr, lii) -> DeliveryPlanItem alloc tcr lii alloc.deliveryDate) items
              quoteItems = map (\((alloc, price), tcr, lii) -> PricedWarehouseAllocation alloc.allocation price) items --TODO: fix price (quantity * unitPrice)
          deliveryPlanCid <- create DeliveryPlan with
            items = deliveryItems, ..
          create AggregatedQuoteTrigger with
            items = quoteItems, ..

template AggregatedQuoteTrigger
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory supplier

    controller seller can
      AggregatedQuoteTrigger_Execute: ContractId AggregatedQuote
        do
          create AggregatedQuote with ..


template AggregatedQuote
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    deliveryPlanCid: ContractId DeliveryPlan
  where
    signatory seller
    controller seller can
      AggregatedQuote_AddMargin: ContractId Quote
        with
          margin: Int
        do
          let itemsWithMargin = items -- TODO Add price and margin
          deliveryPlan <- fetch deliveryPlanCid
          deliveryItems <- forA deliveryPlan.items (\item -> do
              req <- create PaymentRequest with
                price = (head itemsWithMargin).price, .. --FIXME
              return DeliveryAndPaymentPlanItem with
                allocation = item.allocation
                transportCapacityLockCid = item.transportCapacityLockCid
                paymentRequestCid = req
                deliveryDate = item.deliveryDate
                lockedInventoryItemCid = item.lockedInventoryItemCid
            )
          deliveryPlanCid <- create DeliveryAndPaymentPlan with
            items = deliveryItems, ..
          create Quote with
                  items = itemsWithMargin, ..
                  -- TODO Actual items on quote should be (Product - Price - Quantity) /not aggregated/


data DeliveryPlanItem = DeliveryPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    deliveryDate: Date
  deriving (Eq, Show)

template DeliveryPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryPlanItem]
  where
    signatory supplier
    observer seller

data DeliveryAndPaymentPlanItem = DeliveryAndPaymentPlanItem with
    allocation: TransportedWarehouseAllocation
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    paymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  deriving (Eq, Show)

template DeliveryAndPaymentPlan
  with
    quoteId: ContractId QuoteRequest
    supplier: Party
    buyer: Party
    seller: Party
    items: [DeliveryAndPaymentPlanItem]
  where
    signatory seller

    controller seller can
      DeliveryPlan_Start: [ContractId DeliveryInstruction]
        do
          forA items (\item -> create DeliveryInstruction with
              productName = item.allocation.allocation.productName
              warehouse = item.allocation.allocation.warehouse
              quantity = item.allocation.allocation.quantity
              transportCompany = item.allocation.transportCompany
              transportCapacityLockCid = item.transportCapacityLockCid
              lockedInventoryItemCid = item.lockedInventoryItemCid
              paymentRequestCid = item.paymentRequestCid
              deliveryDate = item.deliveryDate, ..
            )

template Quote
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
    items: [PricedWarehouseAllocation] -- TODO add Address!! down from TransportQuoteRequest
    --TODO: do we need the grandtotal?
  where
    signatory seller
    observer buyer

    controller buyer can
      Quote_Accept: ContractId QuoteAccepted
        do
          create QuoteAccepted with ..

template QuoteAccepted
  with
    quoteId: ContractId QuoteRequest
    seller: Party
    buyer: Party
    deliveryPlanCid: ContractId DeliveryAndPaymentPlan
  where
    signatory seller

    controller seller can
      QuoteAccepted_StartDelivery: [ContractId DeliveryInstruction]
        do
          exercise deliveryPlanCid DeliveryPlan_Start

template DeliveryInstruction
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    paymentRequestCid: ContractId PaymentRequest
    deliveryDate: Date
  where
    signatory seller
    observer transportCompany

    controller transportCompany can
      DeliveryInstruction_PickUp: ContractId PickUpRequest
        do
          now <- getTime
          let today = toDateUTC now
          assertMsg ("Pick up should happen on the delivery date: " <> show deliveryDate) $ (today == deliveryDate)
          create PickUpRequest with ..

template PickUpRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    warehouse: Party
    quantity: Int
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    lockedInventoryItemCid: ContractId LockedInventoryItem
    paymentRequestCid: ContractId PaymentRequest
  where
    signatory transportCompany
    observer warehouse

    controller warehouse can
      PickUpRequest_Accept: ContractId Delivery
        do
          lockedInventoryItem <- fetch lockedInventoryItemCid
          assertMsg "aaa" $ lockedInventoryItem.productName == productName
          assertMsg "bbb" $ lockedInventoryItem.quantity >= quantity
          archive lockedInventoryItemCid
          create Delivery with ..

template PaymentRequest
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    price: Decimal
  where
    signatory seller
    observer buyer

    controller buyer can
      PaymentRequest_Pay: ()
        do return ()

template Delivery
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    seller: Party
    productName: Text
    quantity: Int
    warehouse: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
    paymentRequestCid: ContractId PaymentRequest
  where
    signatory warehouse, transportCompany
    observer buyer

    controller buyer can
      Delivery_Pay: ContractId DeliveryAck
        do
          ack <- create DeliveryAck with ..
          exercise paymentRequestCid PaymentRequest_Pay
          return ack

template DeliveryAck
  with
    quoteId: ContractId QuoteRequest
    buyer: Party
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
  where
    signatory buyer
    observer transportCompany

    controller transportCompany can
      DeliveryAck_ReleaseCapacity: ContractId TransportCapacityReleaseTrigger
        do
          create TransportCapacityReleaseTrigger with ..

template TransportCapacityReleaseTrigger
  with
    quoteId: ContractId QuoteRequest
    transportCompany: Party
    transportCapacityLockCid: ContractId LockedTransportCapacity
  where
    signatory transportCompany

    controller transportCompany can
      TransportCapacityReleaseTrigger_Release: ()
        do
          archive transportCapacityLockCid
